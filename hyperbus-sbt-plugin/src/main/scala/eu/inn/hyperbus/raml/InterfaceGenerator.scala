package eu.inn.hyperbus.raml

import java.util.Date

import eu.inn.binders.naming._
import eu.inn.hyperbus.raml.utils.{DashCaseToPascalCaseConverter, DashCaseToUpperSnakeCaseConverter}
import eu.inn.hyperbus.transport.api.uri.{TextToken, UriParser}
import org.raml.v2.api.model.v10.api.Api
import org.raml.v2.api.model.v10.datamodel._
import org.raml.v2.api.model.v10.methods.Method
import org.raml.v2.api.model.v10.resources.Resource
import org.slf4j.LoggerFactory

import scala.collection.JavaConversions._

class InterfaceGenerator(api: Api, options: GeneratorOptions) {
  protected val log = LoggerFactory.getLogger(getClass)
  protected val dashToUpper = new DashCaseToUpperSnakeCaseConverter
  protected val dashToPascal = new DashCaseToPascalCaseConverter
  protected val camelToDash = new CamelCaseToDashCaseConverter

  protected val messageReservedWords = Set(
    "uri", "messageId", "correlationId", "headers", "headerOption", "header", "serialize", "body", "statusCode", "contentType"
  )

  protected val bodyReservedWords = Set(
    "contentType", "links"
  )

  def generate(): String = {
    val builder = new StringBuilder
    if (options.defaultImports) {
      generateImports(builder)
      builder.append("\n// --------------------\n\n")
    }

    options.customImports.foreach { customImports ⇒
      builder.append(customImports)
      builder.append("\n// --------------------\n\n")
    }

    if (options.generatorInformation) {
      generateInformation(builder)
      builder.append("\n// --------------------\n\n")
    }
    generateTypes(builder)
    builder.append("\n// --------------------\n\n")
    generateRequests(builder)
    builder.toString
  }

  protected def generateImports(builder: StringBuilder) = {
    builder.append(
      s"""
         |package ${options.packageName}
         |
         |import eu.inn.binders.annotations.fieldName
         |import eu.inn.hyperbus.model._
         |import eu.inn.hyperbus.model.annotations._
      """.stripMargin
    )
  }

  protected def generateInformation(builder: StringBuilder) = {
    builder.append(
      s"""
        |/*
        | DO NOT EDIT
        | Autogenerated on ${new Date}
        | options: $options
        |*/
        |
      """.stripMargin)
  }

  protected def generateTypes(builder: StringBuilder) = {
    api.types().foreach {
      case obj: ObjectTypeDeclaration ⇒
        generateObjectType(builder, obj)

      case strEl: StringTypeDeclaration ⇒
        generateEnumStrElement(builder, strEl)

      case other ⇒
        log.warn(s"Currently $other is not supported in types")
    }
  }

  protected def generateObjectType(builder: StringBuilder, obj: ObjectTypeDeclaration) = {
    val isBody = api.resources.exists { resource ⇒
      resource.methods.exists { method ⇒
        method.responses.exists { response ⇒
          response.body.exists { body ⇒
            body.`type` == obj.name
          }
        } ||
        method.body.exists { body ⇒
          body.`type` == obj.name
        }
      }
    }

    if (isBody) {
      val getBodyResource = api.resources.find { resource ⇒
        resource.methods.exists { method ⇒
          method.method.toLowerCase == "get" &&
            method.responses.exists { response ⇒
              response.code.value == "200" &&
                response.body.exists { body ⇒
                  body.`type` == obj.name
                }
            }
        }
      }
      val isCreatedBody = api.resources.exists { resource ⇒
        resource.methods.exists { method ⇒
          method.responses.exists { response ⇒
            response.code.value == "201" &&
              response.body.exists { body ⇒
                body.`type` == obj.name
              }
          }
        }
      }

      if (isBody) {
        obj.properties.foreach { prop ⇒
          if (bodyReservedWords.contains(prop.name)) {
            throw new RamlSyntaxException(s"Can't generate class '${obj.name}': '${prop.name}' is a reserved word for a Body")
          }
        }
      }

      builder.append(s"""@body("${options.contentTypePrefix.getOrElse("")}${camelToDash.convert(obj.name)}")\n""")
      builder.append(s"case class ${obj.name}(\n")
      generateCaseClassProperties(builder, obj.properties)
      if (isCreatedBody || getBodyResource.isDefined) {
        builder.append(s""",\n    @fieldName("_links") links: Links.LinksMap""")
        if (getBodyResource.isDefined) {
          builder.append(s""" = ${obj.name}.defaultLinks""")
        }
      }
      builder.append("\n  ) extends Body")
      if (isCreatedBody || getBodyResource.isDefined) {
        builder.append(" with Links")
      }
      if (isCreatedBody) {
        builder.append(" with CreatedBody")
      }
      builder.append("\n\n")

      getBodyResource.map { r ⇒
        builder.append(s"object ${obj.name} extends BodyObjectApi[${obj.name}] {\n")
        builder.append(s"""  val selfPattern = "${r.relativeUri.value}"\n""")
        builder.append(s"""  val defaultLinks = Links(selfPattern, templated = true)\n""")
        builder.append("}\n\n")
      } getOrElse {
        builder.append(s"object ${obj.name} extends BodyObjectApi[${obj.name}]\n\n")
      }
    } else {
      builder.append(s"case class ${obj.name}(\n")
      generateCaseClassProperties(builder, obj.properties)
      builder.append("\n  )\n\n")
    }
  }

  protected def generateRequests(builder: StringBuilder) = {
    api.resources.foreach { resource ⇒
      resource.methods.foreach { method ⇒
        generateRequest(builder, method, resource)
//        if (
//          method.annotations().exists(_.name() ==   value().isInstanceOf[feed])
//          || resource.annotations().exists(_.value().isInstanceOf[feed])
//        ) generateFeedRequest(builder, method, resource)
      }
    }
  }

  // method.method.toUpperCase -> for feed:put -> FEED_PUT
  protected def generateRequest(builder: StringBuilder, method: Method, resource: Resource) = {
    builder.append(s"""@request(Method.${method.method.toUpperCase}, "${resource.relativeUri.value}")\n""")
    val name = requestClassName(resource.relativeUri.value, method.method)
    builder.append(s"case class $name(\n")
    val uriParameters = resource.uriParameters().toSeq

    uriParameters.foreach { prop ⇒
      if (messageReservedWords.contains(prop.name)) {
        throw new RamlSyntaxException(s"Can't generate class '$name' for ${resource.relativeUri.value}: '${prop.name}' is a reserved word for a Request/Response")
      }
    }

    generateCaseClassProperties(builder, uriParameters)
    val bodyType = method.method match {
      case "get" ⇒ "QueryBody"
      case "delete" ⇒ "EmptyBody"
      case _ ⇒
        method.body.headOption.filterNot(_.`type`()=="any").map(_.`type`).getOrElse("DynamicBody")
    }
    if (uriParameters.nonEmpty) {
      builder.append(",\n")
    }
    builder.append(s"    body: $bodyType\n  ) extends Request[$bodyType]\n")
    val successResponses = method.responses.filter{r ⇒ val i = r.code.value.toInt; i >= 200 && i < 400}
    if (successResponses.nonEmpty) {
      if (successResponses.size > 1)
        builder.append("  with DefinedResponse[(\n")
      else
        builder.append("  with DefinedResponse[\n")
      var isFirst = true
      successResponses.foreach { r ⇒
        if (isFirst) {
          builder.append("    ")
        }
        else {
          builder.append(",\n    ")
        }
        isFirst = false
        builder.append(getResponseType(r.code.value))
        builder.append('[')
        val responseBodyType = r.body.headOption.filterNot(_.`type`()=="any").map(_.`type`).getOrElse("DynamicBody")
        builder.append(responseBodyType)
        if (r.code.value == "201" && responseBodyType == "DynamicBody") {
          builder.append(" with CreatedBody")
        }
        builder.append(']')
      }
      if (successResponses.size > 1)
        builder.append("\n  )]\n\n")
      else
        builder.append("\n  ]\n\n")
    } else {
      builder.append("\n")
    }
    builder.append(s"object $name extends RequestObjectApi[$name]\n\n")
  }

//  protected def generateFeedRequest(builder: StringBuilder, method: Method, resource: Resource) = {
//    builder.append(s"""@request(Method.${"FEED_" + method.method.toUpperCase}, "${resource.relativeUri.value}")\n""")
//    val name = requestClassName(resource.relativeUri.value, "feed-" + method.method)
//    builder.append(s"case class $name(\n")
//    val uriParameters = resource.uriParameters().toSeq
//
//    uriParameters.foreach { prop ⇒
//      if (messageReservedWords.contains(prop.name)) {
//        throw new RamlSyntaxException(s"Can't generate class '$name' for ${resource.relativeUri.value}: '${prop.name}' is a reserved word for a Request/Response")
//      }
//    }
//
//    generateCaseClassProperties(builder, uriParameters)
//    val bodyType = method.method match {
//      case "get" ⇒ "QueryBody"
//      case "delete" ⇒ "EmptyBody"
//      case _ ⇒
//        method.body.headOption.flatMap(_.`type`.headOption).getOrElse("DynamicBody")
//    }
//    if (uriParameters.nonEmpty) {
//      builder.append(",\n")
//    }
//    builder.append(s"    body: $bodyType\n  ) extends Request[$bodyType]\n\n")
//  }

  protected def requestClassName(uriPattern: String, method: String): String = {
    val tokens = UriParser.tokens(uriPattern).zipWithIndex
    val last = tokens.reverse.head

    val dashed = tokens.collect {
      case (TextToken(s), index) ⇒
        // this is last token and it's text token, don't depluralize
        // it should be a collection
        if (index == last._2)
          s
        else
          English.singular(s)
    } :+ method mkString "-"
    dashToPascal.convert(dashed)
  }

  protected def generateCaseClassProperties(builder: StringBuilder, properties: Seq[TypeDeclaration]) = {
    var isFirst = true
    properties.foreach { property ⇒
      if (isFirst) {
        builder.append("    ")
      }
      else {
        builder.append(",\n    ")
      }
      isFirst = false
      val (propertyName, isOptional) = {
        val pname = if (property.name.indexOf(':') >= 0) {
          // hyperbus syntax x:@, y:*, etc
          property.name.substring(0, property.name.indexOf(':'))
        } else {
          property.name
        }
        (
          if (pname.endsWith("?")) pname.substring(0, pname.indexOf("?")) else pname,
          pname.endsWith("?") || (property.required != null && !property.required)
          )
      }
      builder.append(propertyName)
      builder.append(": ")
      if (isOptional)
        builder.append("Option[")
      builder.append(mapType(property))
      if (isOptional)
        builder.append("]")
    }
  }

  protected def generateEnumStrElement(builder: StringBuilder, el: StringTypeDeclaration) = {
    builder.append(s"object ${el.name} {\n  type StringEnum = String\n")
    el.enumValues().foreach { e ⇒
      builder.append(s"""  val ${dashToUpper.convert(e)} = "$e"\n""")
    }
    builder.append(s"  lazy val values = Seq(${el.enumValues().map(dashToUpper.convert).mkString(",")})\n")
    builder.append("  lazy val valuesSet = values.toSet\n")
    builder.append("}\n\n")
  }

  // todo: numeric enums?
  protected def mapType(property: TypeDeclaration): String = {
    property match {
      case se : StringTypeDeclaration if se.enumValues().nonEmpty ⇒ se.`type`() + ".StringEnum"
      case _ : StringTypeDeclaration ⇒ "String"
      case _ : IntegerTypeDeclaration ⇒ "Int"
      case n : NumberTypeDeclaration ⇒ n.format match {
        case "int32" | "int" ⇒ "Int"
        case "int64" | "long" ⇒ "Long"
        case "float" ⇒ "Float"
        case "double" ⇒ "Double"
        case "int16" ⇒ "Short"
        case "int8" ⇒ "Byte"
        case _ ⇒ "Double"
      }
      case _ : BooleanTypeDeclaration ⇒ "Boolean"
      case _ : DateTypeDeclaration | _: DateTimeTypeDeclaration |
           _: DateTimeOnlyTypeDeclaration | _: TimeOnlyTypeDeclaration ⇒ "java.util.Date"
      case a : ArrayTypeDeclaration ⇒
        "Seq[" + mapType(stripArrayEnding(a.`type`())) + "]"
      case d: ObjectTypeDeclaration ⇒ d.`type` match {
        case "object"
          if d.properties.size == 1 &&
          d.properties.headOption.exists(_.name.startsWith("["))
        ⇒ "Map[String," + mapType(d.properties.get(0)) + "]"

        case t ⇒ t
      }
      case other ⇒
        log.warn(s"Can't map type $other")
        "Any"
    }
  }

  protected def mapType(`type`: String): String = `type` match {
    case "string" ⇒ "String"
    case "integer" ⇒ "Long" // todo: support Int with annotations?
    case "number" ⇒ "Double"
    case "boolean" ⇒ "Boolean"
    case "date" ⇒ "java.util.Date"
    case other ⇒
      api.types.find(_.name == `type`) match {
        case Some(str: StringTypeDeclaration) ⇒
          if (str.enumValues().nonEmpty) {
            other + ".StringEnum" // enum
          }
          else {
            other
          }
        case _ ⇒ other
      }
  }

  protected def stripArrayEnding(s:String): String = {
    if (s.endsWith("[]"))
      s.substring(0,s.length-2)
    else
      s
  }

  protected def getResponseType(code: String) = code match {
    case "200" ⇒ "Ok"
    case "201" => "Created"
    case "202" => "Accepted"
    case "203" => "NonAuthoritativeInformation"
    case "204" => "NoContent"
    case "205" => "ResetContent"
    case "206" => "PartialContent"
    case "207" => "MultiStatus"

    case "300" => "MultipleChoices"
    case "301" => "MovedPermanently"
    case "302" => "Found"
    case "303" => "SeeOther"
    case "304" => "NotModified"
    case "305" => "UseProxy"
    case "307" => "TemporaryRedirect"

    case _ ⇒ "???"
  }
}

